import { supabase } from '../config/supabase.js';

// –°–µ—Ä–≤–∏—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏
export class UserService {
  // –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
  static async register(userData) {
    try {
      const { data, error } = await supabase
        .from('users')
        .insert([{
          name: userData.name,
          email: userData.email,
          phone: userData.phone,
          password_hash: userData.password // –í —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ –Ω—É–∂–Ω–æ —Ö–µ—à–∏—Ä–æ–≤–∞—Ç—å
        }])
        .select()
        .single();

      if (error) throw error;
      return data;
    } catch (error) {
      console.error('Error registering user:', error);
      throw error;
    }
  }

  // –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
  static async authenticate(email, password) {
    try {
      const { data, error } = await supabase
        .from('users')
        .select('*')
        .eq('email', email)
        .eq('password_hash', password)
        .single();

      if (error) throw error;
      
      // –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –≤—Ö–æ–¥–∞
      await this.updateLastLogin(data.id);
      
      return data;
    } catch (error) {
      console.error('Error authenticating user:', error);
      throw error;
    }
  }

  // –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –ø–æ email –∏–ª–∏ —Ç–µ–ª–µ—Ñ–æ–Ω—É
  static async authenticateByEmailOrPhone(identifier, password) {
    try {
      let query = supabase
        .from('users')
        .select('*')
        .eq('password_hash', password);

      if (identifier.includes('@')) {
        query = query.eq('email', identifier);
      } else {
        query = query.eq('phone', identifier);
      }

      const { data, error } = await query.single();

      if (error) throw error;
      
      // –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –≤—Ö–æ–¥–∞
      await this.updateLastLogin(data.id);
      
      return data;
    } catch (error) {
      console.error('Error authenticating user:', error);
      throw error;
    }
  }

  // –ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ email
  static async findByEmail(email) {
    try {
      const { data, error } = await supabase
        .from('users')
        .select('*')
        .eq('email', email)
        .single();

      if (error && error.code !== 'PGRST116') throw error;
      return data;
    } catch (error) {
      console.error('Error finding user by email:', error);
      throw error;
    }
  }

  // –ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ —Ç–µ–ª–µ—Ñ–æ–Ω—É
  static async findByPhone(phone) {
    try {
      const { data, error } = await supabase
        .from('users')
        .select('*')
        .eq('phone', phone)
        .single();

      if (error && error.code !== 'PGRST116') throw error;
      return data;
    } catch (error) {
      console.error('Error finding user by phone:', error);
      throw error;
    }
  }

  // –ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ ID
  static async findById(id) {
    try {
      const { data, error } = await supabase
        .from('users')
        .select('*')
        .eq('id', id)
        .single();

      if (error && error.code !== 'PGRST116') throw error;
      return data;
    } catch (error) {
      console.error('Error finding user by ID:', error);
      throw error;
    }
  }

  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
  static async update(id, updates) {
    try {
      const { data, error } = await supabase
        .from('users')
        .update(updates)
        .eq('id', id)
        .select()
        .single();

      if (error) throw error;
      return data;
    } catch (error) {
      console.error('Error updating user:', error);
      throw error;
    }
  }

  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –≤—Ö–æ–¥–∞
  static async updateLastLogin(id) {
    try {
      const { error } = await supabase
        .from('users')
        .update({ last_login_at: new Date().toISOString() })
        .eq('id', id);

      if (error) throw error;
    } catch (error) {
      console.error('Error updating last login:', error);
      throw error;
    }
  }

  // –ü–æ–ª—É—á–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ –∑–∞–∫–∞–∑–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
  static async getUserOrders(userId) {
    try {
      const { data, error } = await supabase
        .from('orders')
        .select(`
          *,
          order_items (*)
        `)
        .eq('user_id', userId)
        .order('created_at', { ascending: false });

      if (error) throw error;
      return data;
    } catch (error) {
      console.error('Error getting user orders:', error);
      throw error;
    }
  }

  // –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
  static async getUserStats(userId) {
    try {
      const { data: orders, error } = await supabase
        .from('orders')
        .select('*')
        .eq('user_id', userId);

      if (error) throw error;

      const totalOrders = orders.length;
      const totalSpent = orders.reduce((sum, order) => sum + parseFloat(order.final_total), 0);
      const completedOrders = orders.filter(order => order.status === 'completed').length;
      const averageOrderValue = totalOrders > 0 ? totalSpent / totalOrders : 0;

      // –ü–æ–ª—É—á–∞–µ–º –ø–æ–ø—É–ª—è—Ä–Ω—ã–µ –±–ª—é–¥–∞
      const { data: orderItems, error: itemsError } = await supabase
        .from('order_items')
        .select('dish_name, quantity')
        .in('order_id', orders.map(o => o.id));

      if (itemsError) throw itemsError;

      const dishCounts = {};
      orderItems.forEach(item => {
        dishCounts[item.dish_name] = (dishCounts[item.dish_name] || 0) + item.quantity;
      });

      const favoriteDishes = Object.entries(dishCounts)
        .sort(([,a], [,b]) => b - a)
        .slice(0, 5)
        .map(([name, count]) => ({ name, count }));

      return {
        totalOrders,
        totalSpent,
        completedOrders,
        averageOrderValue,
        favoriteDishes,
        memberSince: orders[0]?.created_at || null,
        lastOrder: orders[0]?.created_at || null
      };
    } catch (error) {
      console.error('Error getting user stats:', error);
      throw error;
    }
  }

  // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
  static async userExists(email) {
    try {
      const user = await this.findByEmail(email);
      return !!user;
    } catch (error) {
      console.error('Error checking user existence:', error);
      return false;
    }
  }

  // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ —Ç–µ–ª–µ—Ñ–æ–Ω—É
  static async userExistsByPhone(phone) {
    try {
      const user = await this.findByPhone(phone);
      return !!user;
    } catch (error) {
      console.error('Error checking user existence by phone:', error);
      return false;
    }
  }

  // –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –∞–¥–º–∏–Ω–∞
  static async authenticateAdmin(email, password) {
    try {
      console.log('üîê –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –∞–¥–º–∏–Ω–∞:', email);
      
      const { data, error } = await supabase
        .from('admins')
        .select('*')
        .eq('email', email)
        .eq('is_active', true)
        .single();

      if (error) {
        console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ –∞–¥–º–∏–Ω–∞:', error);
        throw error;
      }

      if (!data) {
        throw new Error('–ê–¥–º–∏–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω');
      }

      // –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞—Ä–æ–ª—è (–≤ —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–æ–µ–∫—Ç–µ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ bcrypt)
      if (password === 'admin123') {
        console.log('‚úÖ –ê–¥–º–∏–Ω –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω:', data);
        return {
          id: data.id,
          email: data.email,
          name: data.name,
          role: 'admin',
          isAdmin: true
        };
      } else {
        throw new Error('–ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å');
      }
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –∞–¥–º–∏–Ω–∞:', error);
      throw error;
    }
  }
}
